<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- Tell IE to use the latest, best version. -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <title>3D View - Flight Review</title>
  <script src="plot_app/static/cesium/Build/Cesium/Cesium.js"></script>
  <script src="plot_app/static/js/two.min.js"></script>
  <script src="plot_app/static/js/radio_controller.js"></script>

  <!-- Javascript library of plot.ly.-->
  <script src="plot_app/static/js/plotly-latest.min.js"></script>

  <style>
      @import url(plot_app/static/cesium/Build/Cesium/Widgets/widgets.css);
      @import url(plot_app/static/cesium/Build/Cesium/Widgets/lighter.css);
      html, body, #cesiumContainer {
          width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
      }
	  body {
		  background: #000;
		  color: #eee;
		  font-family: sans-serif;
		  font-size: 9pt;
		  padding: 0;
		  margin: 0;
		  width: 100%;
		  height: 100%;
		  overflow: hidden;
	  }
	  #toolbar {
		  background: rgba(42, 42, 42, 0.8);
		  padding: 4px;
		  border-radius: 4px;
		  margin: 5px;
		  padding: 2px 5px;
		  position: absolute;
		  top: 0;
		  left: 0;
	  }
	  #toolbar input {
		  vertical-align: middle;
		  padding-top: 2px;
		  padding-bottom: 2px;
	  }
	  #toolbar td:not(.noalign) {
		  text-align: right;
	  }
	  #toolbar .header {
		  font-weight: bold;
	  }
	  #toolbar a {
		  font-size: 1.5em;
		  color: #fff;
	  }

	  #toolbar a:link, a:visited {
		  text-decoration: none;
	  }
	  #toolbar a:hover, a:focus, a:active {
		  text-decoration: underline;
	  }

      #radio-controller {
		  position: absolute;
		  width: 300px;
		  height: 100px;
		  top: 100%;
		  left: 100%;
		  margin-left: -320px;
		  margin-top: -350px;
      }

    #Chart2D_Left {
		z-index: 2;
		width: 500px;
		height:150px; 
	    position:absolute;
	    left:0;
	    right:0;
	    bottom: 15%;
	    margin-left:2%;
	    margin-right:auto;
	}

    #Chart2D_Right {
		z-index: 2;
		width: 500px;
		height:150px; 
	    position:absolute;
	    left:0;
	    right:0;
	    bottom: 40%;
	    margin-left:2%;
	    margin-right:auto;
	}	

    #Chart2D_Bottom {
		z-index: 2;
		width: 500px;
		height:150px; 
	    position:absolute;
	    left:0;
	    right:0;
	    bottom: 65%;
	    margin-left:2%;
	    margin-right:auto;
	}		

	#DataSelector{
		z-index: 3;
		width: 100px;
		height:20px; 
	    position:absolute;
	    left:0;
	    right:0;
	    bottom: 10%;
	    margin-left:auto;
	    margin-right:1%;				
	}

  </style>
</head>
<body>

	<!-- All HTML-side code for 2D Charting is below.  They depend on css classes: DataSelector, Chart2D_Bottom, Chart2D_Right, Chart2D_Left.
	Don't mind the naming. -->
	<div id="Chart2D_Left" >
		<select id="DataSelector" class="DataSet">
		<option value="Attitude">Attitude</option>
		<option value="Attitude_Rate">Attitude Rate</option>option>
		<option value="Position" selected="selected">Position</option>
		<option value="Velocity">Velocity</option>
		<option value="Controls">Controls</option>
		<option value="Raw_Sensors">Raw Sensors</option>
		<option value="Actuator_Outputs">Actuator Outputs</option>option>
		</select>
	</div>
	<div id="Chart2D_Right" >
		<select id="DataSelector" class="DataSet2">
		<option value="Attitude">Attitude</option>
		<option value="Attitude_Rate" selected="selected">Attitude Rate</option>option>
		<option value="Position">Position</option>
		<option value="Velocity">Velocity</option>
		<option value="Controls">Controls</option>
		<option value="Raw_Sensors">Raw Sensors</option>
		<option value="Actuator_Outputs">Actuator Outputs</option>option>
		</select>
	</div> 
	<div id="Chart2D_Bottom" >
		<select id="DataSelector" class="DataSet3">
		<option value="Attitude" selected="selected">Attitude</option>
		<option value="Attitude_Rate">Attitude Rate</option>option>
		<option value="Position">Position</option>
		<option value="Velocity">Velocity</option>
		<option value="Controls">Controls</option>
		<option value="Raw_Sensors">Raw Sensors</option>
		<option value="Actuator_Outputs">Actuator Outputs</option>option>
		</select>
	</div>   

  <div id="cesiumContainer" style="z-index: 1;position: absolute;"></div>
  <div id="radio-controller" style="z-index: 1;position: absolute;"></div>

  <div id="toolbar" style="z-index: 2;position: absolute;">
	  <table><tbody>
			  <tr>
				  <td class="noalign" colspan="2"><a href="plot_app?log={{ log_id }}">Open Plot Page</a></td>
			  </tr>
			  <!-- <tr><td class="header">Options</td></tr> -->
			  <tr>
				  <td>Model Size</td>
				  <td>
					  <input type="range" min="1" max="100" step="1" data-bind="value: size, valueUpdate: 'input'">
					  <input type="text" size="2" data-bind="value: size">
				  </td>
			  </tr>
			  <tr>
				  <td>Show Flight Path</td>
				  <td>
					  <input type="checkbox" value="true" data-bind="checked: path_visible, valueUpdate: 'input'">
				  </td>
			  </tr>
			  <tr>
				  <td>Camera Tracks Vehicle</td>
				  <td>
					  <input type="checkbox" value="false" data-bind="checked: track_vehicle, valueUpdate: 'input'">
				  </td>
			  </tr>
		  </tbody></table>
  </div>

  <script>


{% if bing_api_key != '' %}
Cesium.BingMapsApi.defaultKey = "{{ bing_api_key }}";
{% endif %}

{% if cesium_api_key != '' %}
Cesium.Ion.defaultAccessToken = "{{ cesium_api_key }}";
{% endif %}

var viewer = new Cesium.Viewer('cesiumContainer', {
    terrainProviderViewModels : [], //Disable terrain changing
    infoBox : false, //Disable InfoBox widget
    selectionIndicator : false, //Disable selection indicator
	navigationInstructionsInitiallyVisible : false
});
var scene = viewer.scene;

//Lighting based on sun/moon positions
scene.globe.enableLighting = false; // generally a bit too dark when enabled

//Terrain
viewer.terrainProvider = Cesium.createWorldTerrain({
    requestWaterMask: true,
    requestVertexNormals: true
});

//Enable depth testing so things behind the terrain disappear.
scene.globe.depthTestAgainstTerrain = true;

var skyAtmosphere = scene.skyAtmosphere;
skyAtmosphere.brightnessShift = 0.2;

//Set the random number seed for consistent results.
Cesium.Math.setRandomNumberSeed(3);

// input data from the log file (via jinja arguments)
var flight_modes = {{ flight_modes }};
var manual_control_setpoints = {{ manual_control_setpoints }};
var takeoff_altitude = {{ takeoff_altitude }};
var takeoff_position = Cesium.Cartographic.fromDegrees(
	{{ takeoff_longitude }}, {{ takeoff_latitude }});
var position_data = {{ position_data }};
var start = Cesium.JulianDate.fromIso8601({{ start_timestamp }});
var boot_timestamp = Cesium.JulianDate.fromIso8601({{ boot_timestamp }});
var stop = Cesium.JulianDate.fromIso8601({{ end_timestamp }});
var attitude_data = {{ attitude_data }};
var vehicle_attitude_setpoint_data = {{vehicle_attitude_setpoint_data}};
var vehicle_local_position_data = {{vehicle_local_position_data}};
var vehicle_local_position_setpoint_data = {{vehicle_local_position_setpoint_data}};
var actuator_outputs_data = {{actuator_outputs_data}};
var vehicle_rates_setpoint_data = {{vehicle_rates_setpoint_data}};
var sensor_combined_data = {{sensor_combined_data}};
var actuator_controls_0_data = {{actuator_controls_0_data}};

var model_scale_factor = {{ model_scale_factor }}; // model-specific scale factor
var model_uri = "{{ model_uri }}";

// Color codes used in static charts
colors8 = ['#e0212d', '#208900', '#2877a2', '#333333', '#999999', '#e58C33', '#33e5e5', '#e533e5']

//Make sure viewer is at the desired time.
viewer.clock.startTime = start.clone();
viewer.clock.stopTime = stop.clone();
viewer.clock.currentTime = start.clone();
viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP; //Loop at the end
viewer.clock.multiplier = 1;
viewer.clock.shouldAnimate = false; // do not autoplay

viewer.animation.viewModel.setShuttleRingTicks([
	0.01, 0.02, 0.05,
	0.1, 0.25, 0.5,
	1, 2, 5, 10, 15, 30, 60,
	100, 300, 600, 1000]);

//Set timeline to simulation bounds
viewer.timeline.zoomTo(start, stop);

function computePositionProperty(altitude_offset) {
    var property = new Cesium.SampledPositionProperty();
	var position;
    
    for (var i = 0; i < position_data.length; ++i) {
        var cur_pos = position_data[i];
        var time = Cesium.JulianDate.fromIso8601(cur_pos[0]);
        position = Cesium.Cartesian3.fromDegrees(cur_pos[1], cur_pos[2],
			cur_pos[3] + altitude_offset);
        property.addSample(time, position);

        //Also create a point for each sample we generate.
        /*
		// TODO: if enabled, take takeoff offset into account (avoid adding twice)
        viewer.entities.add({
            position : position,
            point : {
                pixelSize : 8,
                color : Cesium.Color.TRANSPARENT,
                outlineColor : Cesium.Color.YELLOW,
                outlineWidth : 3
            }
        });
        */
    }
    return property;
}

function computeOrientationProperty() {
	//var orientationProperty = new Cesium.SampledProperty(Cesium.Quaternion);
	var orientationProperty = new Cesium.TimeIntervalCollectionProperty();

	var origin = Cesium.Cartesian3.fromRadians(takeoff_position.longitude,
		 takeoff_position.latitude);
	// assumes the position over the whole flight does not change too much
	// (we neglect the earth curvature)

	var transform_matrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);
	// get 3x3 rot matrix
    var rotation_matrix = new Cesium.Matrix3();
    Cesium.Matrix4.getRotation(transform_matrix, rotation_matrix);

    // rotate by 90 deg to point towards north (instead of east)
    var m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(90.0));
    rotation_matrix = Cesium.Matrix3.multiply(rotation_matrix, m, new Cesium.Matrix3());
    // rotation quaterion from ENU to ECEF
    var q_enu_to_ecef = Cesium.Quaternion.fromRotationMatrix(rotation_matrix);

    for (i = 0; i < attitude_data.length; ++i) {
        var cur_attitude = attitude_data[i];
        var time_att = Cesium.JulianDate.fromIso8601(cur_attitude[0]);
        // we need to swap the y & z axis: in NED the body-frame y-axis points to the right
        // and the z axis down, whereas in ECEF the y-axis points to the left and the z-axis
        // upwards (x-axis points forward in both coordinate systems)
        var q = new Cesium.Quaternion(cur_attitude[1], -cur_attitude[2],
                                               -cur_attitude[3], cur_attitude[4]);
        var orientation = new Cesium.Quaternion();
        Cesium.Quaternion.multiply(q_enu_to_ecef, q, orientation);
        //orientationProperty.addSample(time_att, orientation); // this uses interpolation
        
        // avoid using iterpolation (which causes problems)
        if (i < attitude_data.length - 1) {
            var next_attitude = attitude_data[i+1];
            var time_att_next = Cesium.JulianDate.fromIso8601(next_attitude[0]);
			var timeInterval = new Cesium.TimeInterval({
				start : time_att,
				stop : time_att_next,
				isStartIncluded : true,
				isStopIncluded : false,
				data : orientation
			});
			orientationProperty.intervals.addInterval(timeInterval);
        }
        
    }
    
    return orientationProperty;
}

//Compute the entity position & orientation properties
var positionProperty = computePositionProperty(0);
var orientationProperty = computeOrientationProperty();

// flight modes
var flightModesProperty = new Cesium.TimeIntervalCollectionProperty();
for (i = 0; i < flight_modes.length - 1; ++i) {
	var cur_flight_mode = flight_modes[i];
	var next_flight_mode = flight_modes[i+1];
	var cur_time = Cesium.JulianDate.fromIso8601(cur_flight_mode[0]);
	var next_time = Cesium.JulianDate.fromIso8601(next_flight_mode[0]);

	var timeInterval = new Cesium.TimeInterval({
		start : cur_time,
		stop : next_time,
		isStartIncluded : true,
		isStopIncluded : false,
		data : cur_flight_mode[1]
	});
	flightModesProperty.intervals.addInterval(timeInterval);
}

// manual control setpoints
var manualControlSetpointsProperty = new Cesium.TimeIntervalCollectionProperty();
for (i = 0; i < manual_control_setpoints.length - 1; ++i) {
	var cur_sp = manual_control_setpoints[i];
	var next_sp = manual_control_setpoints[i+1];
	var cur_time = Cesium.JulianDate.fromIso8601(cur_sp[0]);
	var next_time = Cesium.JulianDate.fromIso8601(next_sp[0]);
	var manual_control_setpoint = Cesium.Cartesian4.fromElements(cur_sp[1],
		 cur_sp[2], cur_sp[3], cur_sp[4]);

	var timeInterval = new Cesium.TimeInterval({
		start : cur_time,
		stop : next_time,
		isStartIncluded : true,
		isStopIncluded : false,
		data : manual_control_setpoint
	});
	manualControlSetpointsProperty.intervals.addInterval(timeInterval);
}

var default_model_scale = 20;

//Actually create the entity
var entity = viewer.entities.add({

    //Set the entity availability to the same interval as the simulation time.
    availability : new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
        start : start,
        stop : stop
    })]),

    //Use our computed positions & orientations
    position : positionProperty,
    orientation : orientationProperty,

    //Load the Cesium plane model to represent the entity
    model : {
        uri : model_uri,
        minimumPixelSize : 64,
        scale: default_model_scale * model_scale_factor,
    },

    //Show the path as a yellow line
    path : {
        resolution : 1,
        material : new Cesium.PolylineGlowMaterialProperty({
            glowPower : 0.1,
            color : Cesium.Color.TEAL
        }),
        width : 10
    }
});

// sample the ground height at takeoff position to get the offset (there can be
// an offset of several meters)
var promise = Cesium.sampleTerrainMostDetailed(viewer.terrainProvider, [ takeoff_position ]);
Cesium.when(promise, function(updatedPositions) {
	var ground_offset = takeoff_position.height - takeoff_altitude;
    console.log('Ground Offset in meters: ' + ground_offset);
	// re-compute the positions taking the ground offset into account.
	// add 2 meters more to allow for inaccuracies
	var positionProperty = computePositionProperty(ground_offset + 2);
	entity.position = positionProperty;
});


// Timeline: show the time the same way as in the plots: use the time since boot
function pad(num, size) {
	var s = num+"";
	while (s.length < size) s = "0" + s;
	return s;
}

function format_timestamp(boot_time_sec, show_ms) {
    var ms = Math.round(boot_time_sec * 1000);
	var sec = Math.floor(ms / 1000);
	var minutes = Math.floor(sec / 60);
	var hours = Math.floor(minutes / 60);
	ms = ms % 1000;
	sec = sec % 60;
	minutes = minutes % 60;

	if (hours > 0) {
		var ret_val = hours + ":" + pad(minutes, 2) + ":" + pad(sec,2)
	} else {
		var ret_val = minutes + ":" + pad(sec,2);
	}
	if (show_ms) {
		ret_val = ret_val + "." + pad(ms, 3);
	}
	return ret_val;
}

var animationViewModel = viewer.animation.viewModel;
animationViewModel.dateFormatter = function() { return ''; };

animationViewModel.timeFormatter = function(date, viewModel) {
	var boot_time = Cesium.JulianDate.secondsDifference(date, boot_timestamp);
	return format_timestamp(boot_time, true);
};

viewer.timeline.makeLabel = function(time) {
	var boot_time = Cesium.JulianDate.secondsDifference(time, boot_timestamp);
	return format_timestamp(boot_time, this._timeBarSecondsSpan < 3600);
};

viewer.timeline.updateFromClock();
viewer.timeline.zoomTo(viewer.clock.startTime, viewer.clock.stopTime);


//// 2D CHARTING/STREAMING \\\\

// Helper Functions \\

// RPY data is computed from quaternion. Used for 2D Charting.
function ComputeRollPitchYaw(quaternionArray_IN)
{
	// This is the return value of the function
	var dataRollPitchYaw = [];

	for (i = 0; i < quaternionArray_IN.length; ++i)
	{
		var currentAttitude = quaternionArray_IN[i];
		var myQuaternion = new Cesium.Quaternion(currentAttitude[1], -currentAttitude[2],-currentAttitude[3], currentAttitude[4]);
		var myRollPitchYawRad = Cesium.HeadingPitchRoll.fromQuaternion(myQuaternion)
		var myRollPitchYawDeg = [Cesium.Math.toDegrees(myRollPitchYawRad.roll), Cesium.Math.toDegrees(myRollPitchYawRad.pitch),Cesium.Math.toDegrees(myRollPitchYawRad.heading)]
		dataRollPitchYaw.push(myRollPitchYawDeg);
	}
	return dataRollPitchYaw;
}

// Number of buttons and traces are computed from input arrays so make sure input array dimensions are correct.
function CreateButton(buttonNameList_IN, buttonVisibilityArray_IN, traceColorArray_IN, yAxisLabel_IN)
{
	var numberOfButtons_IN = buttonNameList_IN.length;
	var buttonArray = [];

	// Don't run this function with less thatn 2 args.
	if(arguments.length < 2){return;}

	// Default button
	if(arguments.length == 2)
	{
		for (var buttonIndex = 0 ; buttonIndex<numberOfButtons_IN; buttonIndex++)
		{
			buttonArray.push(
			{
				args: [{'visible': buttonVisibilityArray_IN[buttonIndex]}],
			    label:buttonNameList_IN[buttonIndex],            
			    method: 'update'
			} );
		}	
	}
	// Button with trace color change functionality.
	if(arguments.length == 3)
	{
		for (var buttonIndex = 0 ; buttonIndex<numberOfButtons_IN; buttonIndex++)
		{
			buttonArray.push(
			{
				args: [{'visible': buttonVisibilityArray_IN[buttonIndex], 'line': traceColorArray_IN[buttonIndex]}],
			    label:buttonNameList_IN[buttonIndex],            
			    method: 'update'
			} );
		}			
	}

	// Button with trace color change & y-axis change functionalities.
	if(arguments.length == 4)
	{
		for (var buttonIndex = 0 ; buttonIndex<numberOfButtons_IN; buttonIndex++)
		{
			buttonArray.push(
			{
				args: [{'visible': buttonVisibilityArray_IN[buttonIndex], 'line': traceColorArray_IN[buttonIndex]},{'yaxis': {title: yAxisLabel_IN[buttonIndex] ,titlefont:{color: '#ffffff'},tickfont:{color: '#00ffff'}}}],
			    label:buttonNameList_IN[buttonIndex],            
			    method: 'update'
			} );
		}			
	}

	return buttonArray;
}

// Input is time array as collected from Python side ulog file. Output is x-axis data ready to be plotted in plotly. Output time unit is mintues.
function TimeAxisArrayBuilder(timeData_IN, startTime_IN)
{
	for(var i = 0; i < timeData_IN.length; i++) 
	{
		timeData_IN[i] = Cesium.JulianDate.fromIso8601(timeData_IN[i]).secondsOfDay/60.0 - startTime_IN;
	}

	return timeData_IN;
}

// Simple function iterates over array and does conversion.
function Rad2Deg(radArray_IN)
{
	for(var i = 0; i < radArray_IN.length; i++) 
	{
		radArray_IN[i] = radArray_IN[i]*57.2958;
	}
	return radArray_IN;
}

// Create a trace. Inputs are x and y axis data.
function CreateTrace(xData_IN, yData_IN, traceColor_IN, traceName_IN, traceVisible_IN)
{
	return {x: xData_IN, y: yData_IN, line: {color: traceColor_IN}, name: traceName_IN, visible: traceVisible_IN};	
}

// Create a layout. Inputs are buttons, total data time in seconds, and y-axis label.
function CreateLayout(buttons_IN, totalTime_IN, yLabel_IN)
{
	// We create the buttons and the user control options.
	var updatemenus = [
	{
	    buttons: buttons_IN,
	    direction: 'left',
	    pad: {'r': 0, 't': 0},
	    showactive: true,
	    type: 'buttons',
	    x: 0.0,
	    xanchor: 'left',
	    y: -0.58,
	    yanchor: 'bottom'
	}];

	// We embed the user control options into the layout object.
	var updateLayout = {
	showlegend: false,	
	xaxis: 
	{
		range: [-totalTime_IN, totalTime_IN],
		title: 'Time [sec]',
		titlefont:
		{
			color: '#ffffff'
		},	
		tickfont:
		{
			color: '#00ffff'
		}	
	},

	yaxis: 
	{
		title: yLabel_IN,
		titlefont:
		{
			color: '#ffffff'
		},
		tickfont:
		{
			color: '#00ffff'
		}	
	},	

	shapes: [
	{
		type: 'line',
		xref: 'paper',
		yref: 'paper',
		x0: 0.5,
		y0: 0,
		x1: 0.5,
		y1: 1,
		line: 
		{
			color: '#ffffff',
			width: 2,
			dash: 'dashdot'
		}
	}],

	paper_bgcolor: 'rgba(0,0,0,0.5)',

	plot_bgcolor: 'rgba(0,0,0,0.5)',  

	margin: 
	{
		l: 50,
		r: 10,
		b: 20,
		t: 10,
		pad: 0
	},

	updatemenus: updatemenus
	};	

	return updateLayout;
};

// Grabs a column from a 2D matrix
function ColumnGrabber(matrix_IN, columnIndex_IN)
{
	return matrix_IN.map(function(value,index) {return value[columnIndex_IN];});
}

// DATA COLLECTION \\
// Collect data to be charted
var totalTimeInSec = (stop.secondsOfDay-start.secondsOfDay)/60.0;

// Collect attitude data
var attitude_RPY = ComputeRollPitchYaw(attitude_data);

// Collect attitude rate data
var rollRate = ColumnGrabber(attitude_data,5);
var pitchRate = ColumnGrabber(attitude_data,6);
var yawRate = ColumnGrabber(attitude_data,7);

// Collect attitude rate setpoint data
var rollRateSP = ColumnGrabber(vehicle_rates_setpoint_data,1);
var pitchRateSP = ColumnGrabber(vehicle_rates_setpoint_data,2);
var yawRateSP = ColumnGrabber(vehicle_rates_setpoint_data,3);

// Collect Position data
var positionLocalX = ColumnGrabber(vehicle_local_position_data,1);
var positionLocalY = ColumnGrabber(vehicle_local_position_data,2);
var positionLocalZ = ColumnGrabber(vehicle_local_position_data,3);

// Collect Position setpoint data
var positionLocalXSP = ColumnGrabber(vehicle_local_position_setpoint_data,1);
var positionLocalYSP = ColumnGrabber(vehicle_local_position_setpoint_data,2);
var positionLocalZSP = ColumnGrabber(vehicle_local_position_setpoint_data,3);

// Collect Velocity Data
var positionLocalvX = ColumnGrabber(vehicle_local_position_data,4);
var positionLocalvY = ColumnGrabber(vehicle_local_position_data,5);
var positionLocalvZ = ColumnGrabber(vehicle_local_position_data,6);

// Collect Velocity Setpoint Data
var positionLocalvXSP = ColumnGrabber(vehicle_local_position_setpoint_data,4);
var positionLocalvYSP = ColumnGrabber(vehicle_local_position_setpoint_data,5);
var positionLocalvZSP = ColumnGrabber(vehicle_local_position_setpoint_data,6);

// Collect actuator outputs data
var num_actuator_outputs = actuator_outputs_data[0].length - 1; // This only holds true because data is structured in a specific way.
var actuatorOutputs = [];
for(var i = 1; i <= num_actuator_outputs; i++) {
    actuatorOutputs[i-1] = ColumnGrabber(actuator_outputs_data,i);
}

// Collect attitude setpoint data
var rollSP = ColumnGrabber(vehicle_attitude_setpoint_data,1);
var pitchSP = ColumnGrabber(vehicle_attitude_setpoint_data,2);
var yawSP = ColumnGrabber(vehicle_attitude_setpoint_data,3);

// Collect Raw Gyro
var rollGyro = ColumnGrabber(sensor_combined_data,1);
var pitchGyro = ColumnGrabber(sensor_combined_data,2);
var yawGyro = ColumnGrabber(sensor_combined_data,3);

// Collect Raw Accel
var xAccel = ColumnGrabber(sensor_combined_data,4);
var yAccel = ColumnGrabber(sensor_combined_data,5);
var zAccel = ColumnGrabber(sensor_combined_data,6);

// Collect actuator controls
var contRoll = ColumnGrabber(actuator_controls_0_data,1);
var contPitch = ColumnGrabber(actuator_controls_0_data,2);
var contYaw = ColumnGrabber(actuator_controls_0_data,3);
var contThrust = ColumnGrabber(actuator_controls_0_data,4);

// Collect Manual control
var rcRoll = ColumnGrabber(manual_control_setpoints,1);
var rcPitch = ColumnGrabber(manual_control_setpoints,2);
var rcThrust = ColumnGrabber(manual_control_setpoints,3);
var rcYaw = ColumnGrabber(manual_control_setpoints,4);

// Collect start time of each data stream first.
var positionTime = ColumnGrabber(vehicle_local_position_data,0);
var positionSPTime = ColumnGrabber(vehicle_local_position_setpoint_data,0);
var attitudeTime = ColumnGrabber(attitude_data,0);
var setPointTime = ColumnGrabber(vehicle_attitude_setpoint_data,0);
var actuatorOutputTime = ColumnGrabber(actuator_outputs_data,0);
var attitudeRateSPTime = ColumnGrabber(vehicle_rates_setpoint_data,0);
var sensorCombinedTime = ColumnGrabber(sensor_combined_data,0);
var contTime = ColumnGrabber(actuator_controls_0_data,0);
var rcTime = ColumnGrabber(manual_control_setpoints,0);

// Data collection is finished. Empty the unused arrays.
attitude_data = [];
vehicle_attitude_setpoint_data = [];
vehicle_local_position_data = [];
vehicle_local_position_setpoint_data = [];
actuator_outputs_data = [];
sensor_combined_data = [];
actuator_controls_0_data = [];
manual_control_setpoints = [];
vehicle_rates_setpoint_data = [];

// Rad-2-Deg Conversions \\
rollRate = Rad2Deg(rollRate);
pitchRate = Rad2Deg(pitchRate);
yawRate = Rad2Deg(yawRate);

rollSP = Rad2Deg(rollSP);
pitchSP = Rad2Deg(pitchSP);
yawSP = Rad2Deg(yawSP);

rollRateSP = Rad2Deg(rollRateSP);
pitchRateSP = Rad2Deg(pitchRateSP);
yawRateSP = Rad2Deg(yawRateSP);

rollGyro = Rad2Deg(rollGyro);
pitchGyro = Rad2Deg(pitchGyro);
yawGyro = Rad2Deg(yawGyro);    

// Time Axis Building \\
// Find the earliest data start time
var initialTime = Math.min(Cesium.JulianDate.fromIso8601(setPointTime[0]).secondsOfDay/60.0, Cesium.JulianDate.fromIso8601(attitudeTime[0]).secondsOfDay/60.0,Cesium.JulianDate.fromIso8601(positionTime[0]).secondsOfDay/60.0,Cesium.JulianDate.fromIso8601(positionSPTime[0]).secondsOfDay/60.0,Cesium.JulianDate.fromIso8601(actuatorOutputTime[0]).secondsOfDay/60.0, Cesium.JulianDate.fromIso8601(attitudeRateSPTime[0]).secondsOfDay/60.0, Cesium.JulianDate.fromIso8601(sensorCombinedTime[0]).secondsOfDay/60.0, Cesium.JulianDate.fromIso8601(contTime[0]).secondsOfDay/60.0, Cesium.JulianDate.fromIso8601(rcTime[0]).secondsOfDay/60.0);

// Create x-axis array for attitude
var attitudeXData = TimeAxisArrayBuilder(attitudeTime, initialTime);

// Create x-axis array for attitude setpoint
var attitudeSPXData = TimeAxisArrayBuilder(setPointTime, initialTime);

// Create x-axis array for position data. Be careful with naming posLocalXData denotes x-axis data array. Not x-axis position on the map.
var posLocalXData = TimeAxisArrayBuilder(positionTime, initialTime);

// Create x-axis array for position setpoint data. 
var posSPLocalXData = TimeAxisArrayBuilder(positionSPTime, initialTime);

// Create x-axis array for actuator outputs.
var actuatorOutputsXData = TimeAxisArrayBuilder(actuatorOutputTime, initialTime);

// Create x-axis array attitude rate setpoint	
var attitudeRateSPXData = TimeAxisArrayBuilder(attitudeRateSPTime, initialTime);

// Create x-axis array for sensors combined
var sensorCombinedXData = TimeAxisArrayBuilder(sensorCombinedTime, initialTime);	

// Create x-axis array for actuator controls
var controllerXData = TimeAxisArrayBuilder(contTime, initialTime);

// Create x-axis array for rc setpoints
var rcSPXData = TimeAxisArrayBuilder(rcTime, initialTime);		

// Empty out unused arrays.
attitudeTime = []
setPointTime = []
positionTime = []
positionSPTime = []
actuatorOutputTime = []
attitudeRateSPTime = []
sensorCombinedTime = []
contTime = []
rcTime = []
						
// BUTTON LAYOUT \\										
// Buttons - Attitude
var buttonsAttitude = CreateButton(['All','Roll','Pitch','Yaw'],[[true, true, true, false, false, false],[true, false, false, true, false, false],[false, true, false, false, true, false],[false, false, true, false, false, true]],[[{color: '#FF0000' }, {color: '#00FF00' },{color: '#154D9B' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }],[{color: '#FF0000' }, {color: '#FF0000' },{color: '#FF0000' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }],[{color: '#FF0000' }, {color: '#FF0000' },{color: '#FF0000' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }],[{color: '#FF0000' }, {color: '#FF0000' },{color: '#FF0000' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }]]);

// Buttons - Position
var buttonsPos = CreateButton(['All','X-Position','Y-Position','Z-Position'],[[true, true, true, false, false, false],[true, false, false, true, false, false],[false, true, false, false, true, false],[false, false, true, false, false, true]],[[{color: '#FF0000' }, {color: '#00FF00' },{color: '#154D9B' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }],[{color: '#FF0000' }, {color: '#FF0000' },{color: '#FF0000' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }],[{color: '#FF0000' }, {color: '#FF0000' },{color: '#FF0000' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }],[{color: '#FF0000' }, {color: '#FF0000' },{color: '#FF0000' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }]]);

// Buttons - Angle/Attitude Rate
var buttonsAngleRate = CreateButton(['All','Roll Rate','Pitch Rate','Yaw Rate'],[[true, true, true, false, false, false],[true, false, false, true, false, false],[false, true, false, false, true, false],[false, false, true, false, false, true]],[[{color: '#FF0000' }, {color: '#00FF00' },{color: '#154D9B' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }],[{color: '#FF0000' }, {color: '#FF0000' },{color: '#FF0000' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }], [{color: '#FF0000' }, {color: '#FF0000' },{color: '#FF0000' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }], [{color: '#FF0000' }, {color: '#FF0000' },{color: '#FF0000' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }]]);

// Buttons - Velocity
var buttonsVelocity = CreateButton(['All','X-Speed','Y-Speed','Z-Speed'],[[true, true, true, false, false, false],[true, false, false, true, false, false],[false, true, false, false, true, false],[false, false, true, false, false, true]],[[{color: '#FF0000' }, {color: '#00FF00' },{color: '#154D9B' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }],[{color: '#FF0000' }, {color: '#FF0000' },{color: '#FF0000' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }],[{color: '#FF0000' }, {color: '#FF0000' },{color: '#FF0000' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }],[{color: '#FF0000' }, {color: '#FF0000' },{color: '#FF0000' },{color: '#139709' }, {color: '#139709' },{color: '#139709' }]]);

// Buttons - Raw sensors
var buttonsRawSensors = CreateButton(['Raw Gyro','Raw Accel'],[[true, true, true, false, false, false],[false, false, false, true, true, true]],[[{color: '#FF0000' }, {color: '#00FF00' },{color: '#154D9B' },{color: '#FF0000' }, {color: '#00FF00' },{color: '#154D9B' }],[{color: '#FF0000' }, {color: '#00FF00' },{color: '#154D9B' },{color: '#FF0000' }, {color: '#00FF00' },{color: '#154D9B' }]],['Rate [deg/s]','Accel. [m/s/s]']);
		
// Buttons - Actuator Controls and Manual Control Inputs
buttonsControls = CreateButton(['Actuator Controls','Manual Control Inputs'], [[true, true, true, true, false, false, false, false],[false, false, false, false, true, true, true, true]]);

// Buttons - Actuator Outputs
var actOutputVisibility = new Array(num_actuator_outputs);
for (var i = 0; i < actOutputVisibility.length; ++i) { actOutputVisibility[i] = true; }
buttonsActuatorOutputs = CreateButton(['All'], [actOutputVisibility]);

// 2D Charting Layouts \\
// We create updatemenus first and then pass them into layout variables.
var updateLayoutInitialAttitude = CreateLayout(buttonsAttitude, totalTimeInSec, 'Angle [deg]');
var updateLayoutInitialPos = CreateLayout(buttonsPos, totalTimeInSec, 'Position [m]');
var updateLayoutInitialAngleRate = CreateLayout(buttonsAngleRate, totalTimeInSec, 'Rate [deg/s]');

// Initial data pack for the attitude chart.
var dataInitialAttitude = [CreateTrace(attitudeXData, attitude_RPY.map(function(value,index) { return value[0]; }),'#FF0000','Roll',true), CreateTrace(attitudeXData, attitude_RPY.map(function(value,index) { return value[1]; }),'#00FF00','Pitch',true), CreateTrace(attitudeXData, attitude_RPY.map(function(value,index) { return value[2]; }),'#154D9B','Yaw',true),CreateTrace(attitudeSPXData,rollSP,'#139709','Roll Setpoint',false),CreateTrace(attitudeSPXData,pitchSP,'#139709','Pitch Setpoint',false),CreateTrace(attitudeSPXData,yawSP,'#139709','Yaw Setpoint',false)];

// Initial data pack for the position chart.
var dataInitialPos = [CreateTrace(posLocalXData, positionLocalX,'#FF0000','X-Pos', true), CreateTrace(posLocalXData, positionLocalY,'#00FF00','Y-Pos', true), CreateTrace(posLocalXData, positionLocalZ,'#154D9B','Z-Pos', true),CreateTrace(posSPLocalXData,positionLocalXSP,'#139709','X-Pos Setpoint',false),CreateTrace(posSPLocalXData,positionLocalYSP,'#139709','Y-Pos Setpoint',false),CreateTrace(posSPLocalXData,positionLocalZSP,'#139709','Z-Pos Setpoint',false)];

// Initial data pack for the attitude rate chart.
var dataInitialattitudeRate = [CreateTrace(attitudeXData, rollRate,'#FF0000','Roll Rate',true), CreateTrace(attitudeXData, pitchRate,'#00FF00','Pitch Rate',true), CreateTrace(attitudeXData, yawRate,'#154D9B','Yaw Rate',true),CreateTrace(attitudeRateSPXData,rollRateSP,'#139709','Roll Rate Setpoint',false),CreateTrace(attitudeRateSPXData,pitchRateSP,'#139709','Pitch Rate Setpoint',false),CreateTrace(attitudeRateSPXData,yawRateSP,'#139709','Yaw Rate Setpoint',false)];

// Callback Functions \\
function updateDataSet(input)
{
	// Update function didn't work so I just went with purge+plot. Slower but works.
	Plotly.purge(dataChart)

	switch (datasetSelector.value)
	{
		case 'Attitude':
			var updateLayoutCallBackAttitude = CreateLayout(buttonsAttitude, totalTimeInSec, 'Angle [deg]');
			var dataCallBackAttitude = [CreateTrace(attitudeXData, attitude_RPY.map(function(value,index) { return value[0]; }),'#FF0000','Roll',true), CreateTrace(attitudeXData, attitude_RPY.map(function(value,index) { return value[1]; }),'#00FF00','Pitch',true), CreateTrace(attitudeXData, attitude_RPY.map(function(value,index) { return value[2]; }),'#154D9B','Yaw',true),CreateTrace(attitudeSPXData,rollSP,'#139709','Roll Setpoint',false),CreateTrace(attitudeSPXData,pitchSP,'#139709','Pitch Setpoint',false),CreateTrace(attitudeSPXData,yawSP,'#139709','Yaw Setpoint',false)];
			Plotly.plot(dataChart, dataCallBackAttitude, updateLayoutCallBackAttitude);

			// Release variables
			updateLayoutCallBackAttitude = [];
			dataCallBackAttitude = [];

			break;

		case 'Attitude_Rate':
			var updateLayoutCallBackAttitudeRate = CreateLayout(buttonsAngleRate, totalTimeInSec, 'Rate [deg/s]');
			var dataCallBackAttitudeRate = [CreateTrace(attitudeXData, rollRate,'#FF0000','Roll Rate',true), CreateTrace(attitudeXData, pitchRate,'#00FF00','Pitch Rate',true), CreateTrace(attitudeXData, yawRate,'#154D9B','Yaw Rate',true),CreateTrace(attitudeRateSPXData,rollRateSP,'#139709','Roll Rate Setpoint',false),CreateTrace(attitudeRateSPXData,pitchRateSP,'#139709','Pitch Rate Setpoint',false),CreateTrace(attitudeRateSPXData,yawRateSP,'#139709','Yaw Rate Setpoint',false)];
			Plotly.plot(dataChart, dataCallBackAttitudeRate, updateLayoutCallBackAttitudeRate);

			// Release variables
			updateLayoutCallBackAttitudeRate = [];
			dataCallBackAttitudeRate = [];

			break;

		case 'Position':
			var updateLayoutCallBackPos = CreateLayout(buttonsPos, totalTimeInSec, 'Position [m]');
			var dataCallBackPos = [CreateTrace(posLocalXData, positionLocalX,'#FF0000','X-Pos', true), CreateTrace(posLocalXData, positionLocalY,'#00FF00','Y-Pos', true), CreateTrace(posLocalXData, positionLocalZ,'#154D9B','Z-Pos', true),CreateTrace(posSPLocalXData,positionLocalXSP,'#139709','X-Pos Setpoint',false),CreateTrace(posSPLocalXData,positionLocalYSP,'#139709','Y-Pos Setpoint',false),CreateTrace(posSPLocalXData,positionLocalZSP,'#139709','Z-Pos Setpoint',false)];
			Plotly.plot(dataChart, dataCallBackPos, updateLayoutCallBackPos);

			// Release variables
			updateLayoutCallBackPos = [];
			dataCallBackPos = [];

			break;

		case 'Velocity':
			var updateLayoutCallBackVel = CreateLayout(buttonsVelocity, totalTimeInSec, 'Velocity [m/s]');
			var dataCallBackVel = [CreateTrace(posLocalXData, positionLocalvX,'#FF0000','X-Vel', true), CreateTrace(posLocalXData, positionLocalvY,'#00FF00','Y-Vel', true), CreateTrace(posLocalXData, positionLocalvZ,'#154D9B','Z-Vel', true),CreateTrace(posSPLocalXData,positionLocalvXSP,'#139709','X-Vel Setpoint',false),CreateTrace(posSPLocalXData,positionLocalvYSP,'#139709','Y-Vel Setpoint',false),CreateTrace(posSPLocalXData,positionLocalvZSP,'#139709','Z-Vel Setpoint',false)];
			Plotly.plot(dataChart, dataCallBackVel, updateLayoutCallBackVel);

			// Release variables
			updateLayoutCallBackVel = [];
			dataCallBackVel = [];

			break;

		case 'Raw_Sensors':
			var updateLayoutCallBackSensors = CreateLayout(buttonsRawSensors, totalTimeInSec, 'Rate [deg/s]');
			var dataCallBackSensors = [CreateTrace(sensorCombinedXData, rollGyro,'#FF0000','Roll Gyro', true), CreateTrace(sensorCombinedXData, pitchGyro,'#00FF00','Pitch Gyro', true), CreateTrace(sensorCombinedXData, yawGyro,'#154D9B','Yaw Gyro', true),CreateTrace(sensorCombinedXData,xAccel,'#FF0000','X Accel',false),CreateTrace(sensorCombinedXData,yAccel,'#00FF00','Y Accel',false),CreateTrace(sensorCombinedXData,zAccel,'#139709','Z Accel',false)];
			Plotly.plot(dataChart, dataCallBackSensors, updateLayoutCallBackSensors);

			// Release variables
			updateLayoutCallBackSensors = [];
			dataCallBackSensors = [];

			break;

		case 'Controls':
			var updateLayoutCallBackControls = CreateLayout(buttonsControls, totalTimeInSec, 'N.A.');
			var dataCallBackControls = [CreateTrace(controllerXData, contRoll,'#FF0000','Cont. Roll', true), CreateTrace(controllerXData, contPitch,'#00FF00','Cont. Pitch', true), CreateTrace(controllerXData, contYaw,'#154D9B','Cont. Yaw', true), CreateTrace(controllerXData,contThrust,'#F5FF39','Cont. Thrust',true),CreateTrace(rcSPXData,rcRoll,'#FF0000','RC Roll',false),CreateTrace(rcSPXData,rcPitch,'#00FF00','RC Pitch',false),CreateTrace(rcSPXData,rcYaw,'#154D9B','RC Yaw',false), CreateTrace(rcSPXData,rcThrust,'#F5FF39','RC Thrust',false)];
			Plotly.plot(dataChart, dataCallBackControls, updateLayoutCallBackControls);

			// Release variables
			updateLayoutCallBackControls = [];
			dataCallBackControls = [];

			break;

		case 'Actuator_Outputs':
			var updateLayoutCallBackActuatorOutputs = CreateLayout(buttonsActuatorOutputs, totalTimeInSec, 'P.W.M. [us]');
			var figureDataActOut = [];
			for(var i = 0; i < num_actuator_outputs; i++) 
			{
				figureDataActOut[i] = CreateTrace(actuatorOutputsXData, actuatorOutputs[i],colors8[i],'Output '+i.toString());
			}
			Plotly.plot(dataChart, figureDataActOut, updateLayoutCallBackActuatorOutputs);

			// Release variables
			updateLayoutCallBackActuatorOutputs = [];
			figureDataActOut = [];

			break;			
	};
}

// Callback function for dropdown menu.
function updateDataSet2(input)
{
	// Update function didn't work so I just went purge. Probably slower but works.
	Plotly.purge(dataChart2)
	switch (datasetSelector2.value)
	{
		case 'Attitude':
			var updateLayoutCallBackAttitude = CreateLayout(buttonsAttitude, totalTimeInSec, 'Angle [deg]');
			var dataCallBackAttitude = [CreateTrace(attitudeXData, attitude_RPY.map(function(value,index) { return value[0]; }),'#FF0000','Roll',true), CreateTrace(attitudeXData, attitude_RPY.map(function(value,index) { return value[1]; }),'#00FF00','Pitch',true), CreateTrace(attitudeXData, attitude_RPY.map(function(value,index) { return value[2]; }),'#154D9B','Yaw',true),CreateTrace(attitudeSPXData,rollSP,'#139709','Roll Setpoint',false),CreateTrace(attitudeSPXData,pitchSP,'#139709','Pitch Setpoint',false),CreateTrace(attitudeSPXData,yawSP,'#139709','Yaw Setpoint',false)];
			Plotly.plot(dataChart2, dataCallBackAttitude, updateLayoutCallBackAttitude);

			// Release variables
			updateLayoutCallBackAttitude = [];
			dataCallBackAttitude = [];

			break;

		case 'Attitude_Rate':
			var updateLayoutCallBackAttitudeRate = CreateLayout(buttonsAngleRate, totalTimeInSec, 'Rate [deg/s]');
			var dataCallBackAttitudeRate = [CreateTrace(attitudeXData, rollRate,'#FF0000','Roll Rate',true), CreateTrace(attitudeXData, pitchRate,'#00FF00','Pitch Rate',true), CreateTrace(attitudeXData, yawRate,'#154D9B','Yaw Rate',true),CreateTrace(attitudeRateSPXData,rollRateSP,'#139709','Roll Rate Setpoint',false),CreateTrace(attitudeRateSPXData,pitchRateSP,'#139709','Pitch Rate Setpoint',false),CreateTrace(attitudeRateSPXData,yawRateSP,'#139709','Yaw Rate Setpoint',false)];
			Plotly.plot(dataChart2, dataCallBackAttitudeRate, updateLayoutCallBackAttitudeRate);

			// Release variables
			updateLayoutCallBackAttitudeRate = [];
			dataCallBackAttitudeRate = [];
			break;

		case 'Position':
			var updateLayoutCallBackPos = CreateLayout(buttonsPos, totalTimeInSec, 'Position [m]');
			var dataCallBackPos = [CreateTrace(posLocalXData, positionLocalX,'#FF0000','X-Pos', true), CreateTrace(posLocalXData, positionLocalY,'#00FF00','Y-Pos', true), CreateTrace(posLocalXData, positionLocalZ,'#154D9B','Z-Pos', true),CreateTrace(posSPLocalXData,positionLocalXSP,'#139709','X-Pos Setpoint',false),CreateTrace(posSPLocalXData,positionLocalYSP,'#139709','Y-Pos Setpoint',false),CreateTrace(posSPLocalXData,positionLocalZSP,'#139709','Z-Pos Setpoint',false)];
			Plotly.plot(dataChart2, dataCallBackPos, updateLayoutCallBackPos);

			// Release variables
			updateLayoutCallBackPos = [];
			dataCallBackPos = [];

			break;

		case 'Velocity':
			var updateLayoutCallBackVel = CreateLayout(buttonsVelocity, totalTimeInSec, 'Velocity [m/s]');
			var dataCallBackVel = [CreateTrace(posLocalXData, positionLocalvX,'#FF0000','X-Vel', true), CreateTrace(posLocalXData, positionLocalvY,'#00FF00','Y-Vel', true), CreateTrace(posLocalXData, positionLocalvZ,'#154D9B','Z-Vel', true),CreateTrace(posSPLocalXData,positionLocalvXSP,'#139709','X-Vel Setpoint',false),CreateTrace(posSPLocalXData,positionLocalvYSP,'#139709','Y-Vel Setpoint',false),CreateTrace(posSPLocalXData,positionLocalvZSP,'#139709','Z-Vel Setpoint',false)];
			Plotly.plot(dataChart2, dataCallBackVel, updateLayoutCallBackVel);

			// Release variables
			updateLayoutCallBackVel = [];
			dataCallBackVel = [];

			break;		

		case 'Raw_Sensors':
			var updateLayoutCallBackSensors = CreateLayout(buttonsRawSensors, totalTimeInSec, 'Rate [deg/s]');
			var dataCallBackSensors = [CreateTrace(sensorCombinedXData, rollGyro,'#FF0000','Roll Gyro', true), CreateTrace(sensorCombinedXData, pitchGyro,'#00FF00','Pitch Gyro', true), CreateTrace(sensorCombinedXData, yawGyro,'#154D9B','Yaw Gyro', true),CreateTrace(sensorCombinedXData,xAccel,'#FF0000','X Accel',false),CreateTrace(sensorCombinedXData,yAccel,'#00FF00','Y Accel',false),CreateTrace(sensorCombinedXData,zAccel,'#139709','Z Accel',false)];
			Plotly.plot(dataChart2, dataCallBackSensors, updateLayoutCallBackSensors);

			// Release variables
			updateLayoutCallBackSensors = [];
			dataCallBackSensors = [];

			break;		

		case 'Controls':
			var updateLayoutCallBackControls = CreateLayout(buttonsControls, totalTimeInSec, 'N.A.');
			var dataCallBackControls = [CreateTrace(controllerXData, contRoll,'#FF0000','Cont. Roll', true), CreateTrace(controllerXData, contPitch,'#00FF00','Cont. Pitch', true), CreateTrace(controllerXData, contYaw,'#154D9B','Cont. Yaw', true), CreateTrace(controllerXData,contThrust,'#F5FF39','Cont. Thrust',true),CreateTrace(rcSPXData,rcRoll,'#FF0000','RC Roll',false),CreateTrace(rcSPXData,rcPitch,'#00FF00','RC Pitch',false),CreateTrace(rcSPXData,rcYaw,'#154D9B','RC Yaw',false), CreateTrace(rcSPXData,rcThrust,'#F5FF39','RC Thrust',false)];
			Plotly.plot(dataChart2, dataCallBackControls, updateLayoutCallBackControls);

			// Release variables
			updateLayoutCallBackControls = [];
			dataCallBackControls = [];

			break;			

		case 'Actuator_Outputs':
			var updateLayoutCallBackActuatorOutputs = CreateLayout(buttonsActuatorOutputs, totalTimeInSec, 'P.W.M. [us]');
			var figureDataActOut = []
			for(var i = 0; i < num_actuator_outputs; i++) 
			{
				figureDataActOut[i] = CreateTrace(actuatorOutputsXData, actuatorOutputs[i],colors8[i],'Output '+i.toString());
			}
			Plotly.plot(dataChart2, figureDataActOut, updateLayoutCallBackActuatorOutputs);

			// Release variables
			updateLayoutCallBackActuatorOutputs = [];
			figureDataActOut = [];

			break;					
	};
}

// Callback function for dropdown menu.
function updateDataSet3(input)
{
	// Update function didn't work so I just went with purge+plot. Slower but works.
	Plotly.purge(dataChart3)
	switch (datasetSelector3.value)
	{
		case 'Attitude':
			var updateLayoutCallBackAttitude = CreateLayout(buttonsAttitude, totalTimeInSec, 'Angle [deg]');
			var dataCallBackAttitude = [CreateTrace(attitudeXData, attitude_RPY.map(function(value,index) { return value[0]; }),'#FF0000','Roll',true), CreateTrace(attitudeXData, attitude_RPY.map(function(value,index) { return value[1]; }),'#00FF00','Pitch',true), CreateTrace(attitudeXData, attitude_RPY.map(function(value,index) { return value[2]; }),'#154D9B','Yaw',true),CreateTrace(attitudeSPXData,rollSP,'#139709','Roll Setpoint',false),CreateTrace(attitudeSPXData,pitchSP,'#139709','Pitch Setpoint',false),CreateTrace(attitudeSPXData,yawSP,'#139709','Yaw Setpoint',false)];
			Plotly.plot(dataChart3, dataCallBackAttitude, updateLayoutCallBackAttitude);

			// Release variables
			updateLayoutCallBackAttitude = [];
			dataCallBackAttitude = [];

			break;

		case 'Attitude_Rate':
			var updateLayoutCallBackAttitudeRate = CreateLayout(buttonsAngleRate, totalTimeInSec, 'Rate [deg/s]');
			var dataCallBackAttitudeRate = [CreateTrace(attitudeXData, rollRate,'#FF0000','Roll Rate',true), CreateTrace(attitudeXData, pitchRate,'#00FF00','Pitch Rate',true), CreateTrace(attitudeXData, yawRate,'#154D9B','Yaw Rate',true),CreateTrace(attitudeRateSPXData,rollRateSP,'#139709','Roll Rate Setpoint',false),CreateTrace(attitudeRateSPXData,pitchRateSP,'#139709','Pitch Rate Setpoint',false),CreateTrace(attitudeRateSPXData,yawRateSP,'#139709','Yaw Rate Setpoint',false)];
			Plotly.plot(dataChart3, dataCallBackAttitudeRate, updateLayoutCallBackAttitudeRate);

			// Release variables
			updateLayoutCallBackAttitudeRate = [];
			dataCallBackAttitudeRate = [];
			break;

		case 'Position':
			var updateLayoutCallBackPos = CreateLayout(buttonsPos, totalTimeInSec, 'Position [m]');
			var dataCallBackPos = [CreateTrace(posLocalXData, positionLocalX,'#FF0000','X-Pos', true), CreateTrace(posLocalXData, positionLocalY,'#00FF00','Y-Pos', true), CreateTrace(posLocalXData, positionLocalZ,'#154D9B','Z-Pos', true),CreateTrace(posSPLocalXData,positionLocalXSP,'#139709','X-Pos Setpoint',false),CreateTrace(posSPLocalXData,positionLocalYSP,'#139709','Y-Pos Setpoint',false),CreateTrace(posSPLocalXData,positionLocalZSP,'#139709','Z-Pos Setpoint',false)];
			Plotly.plot(dataChart3, dataCallBackPos, updateLayoutCallBackPos);

			// Release variables
			updateLayoutCallBackPos = [];
			dataCallBackPos = [];

			break;

		case 'Velocity':
			var updateLayoutCallBackVel = CreateLayout(buttonsVelocity, totalTimeInSec, 'Velocity [m/s]');
			var dataCallBackVel = [CreateTrace(posLocalXData, positionLocalvX,'#FF0000','X-Vel', true), CreateTrace(posLocalXData, positionLocalvY,'#00FF00','Y-Vel', true), CreateTrace(posLocalXData, positionLocalvZ,'#154D9B','Z-Vel', true),CreateTrace(posSPLocalXData,positionLocalvXSP,'#139709','X-Vel Setpoint',false),CreateTrace(posSPLocalXData,positionLocalvYSP,'#139709','Y-Vel Setpoint',false),CreateTrace(posSPLocalXData,positionLocalvZSP,'#139709','Z-Vel Setpoint',false)];
			Plotly.plot(dataChart3, dataCallBackVel, updateLayoutCallBackVel);

			// Release variables
			updateLayoutCallBackVel = [];
			dataCallBackVel = [];

			break;		

		case 'Raw_Sensors':
			var updateLayoutCallBackSensors = CreateLayout(buttonsRawSensors, totalTimeInSec, 'Rate [deg/s]');
			var dataCallBackSensors = [CreateTrace(sensorCombinedXData, rollGyro,'#FF0000','Roll Gyro', true), CreateTrace(sensorCombinedXData, pitchGyro,'#00FF00','Pitch Gyro', true), CreateTrace(sensorCombinedXData, yawGyro,'#154D9B','Yaw Gyro', true),CreateTrace(sensorCombinedXData,xAccel,'#FF0000','X Accel',false),CreateTrace(sensorCombinedXData,yAccel,'#00FF00','Y Accel',false),CreateTrace(sensorCombinedXData,zAccel,'#139709','Z Accel',false)];
			Plotly.plot(dataChart3, dataCallBackSensors, updateLayoutCallBackSensors);

			// Release variables
			updateLayoutCallBackSensors = [];
			dataCallBackSensors = [];

			break;				

		case 'Controls':
			var updateLayoutCallBackControls = CreateLayout(buttonsControls, totalTimeInSec, 'N.A.');
			var dataCallBackControls = [CreateTrace(controllerXData, contRoll,'#FF0000','Cont. Roll', true), CreateTrace(controllerXData, contPitch,'#00FF00','Cont. Pitch', true), CreateTrace(controllerXData, contYaw,'#154D9B','Cont. Yaw', true), CreateTrace(controllerXData,contThrust,'#F5FF39','Cont. Thrust',true),CreateTrace(rcSPXData,rcRoll,'#FF0000','RC Roll',false),CreateTrace(rcSPXData,rcPitch,'#00FF00','RC Pitch',false),CreateTrace(rcSPXData,rcYaw,'#154D9B','RC Yaw',false), CreateTrace(rcSPXData,rcThrust,'#F5FF39','RC Thrust',false)];
			Plotly.plot(dataChart3, dataCallBackControls, updateLayoutCallBackControls);

			// Release variables
			updateLayoutCallBackControls = [];
			dataCallBackControls = [];

			break;				

		case 'Actuator_Outputs':
			var updateLayoutCallBackActuatorOutputs = CreateLayout(buttonsActuatorOutputs, totalTimeInSec, 'P.W.M. [us]');
			var figureDataActOut = []
			for(var i = 0; i < num_actuator_outputs; i++) 
			{
				figureDataActOut[i] = CreateTrace(actuatorOutputsXData, actuatorOutputs[i],colors8[i],'Output '+i.toString());
			}
			Plotly.plot(dataChart3, figureDataActOut, updateLayoutCallBackActuatorOutputs);

			// Release variables
			updateLayoutCallBackActuatorOutputs = [];
			figureDataActOut = [];

			break;			
	};
}

// Grab the dropdown menu from html and add a listener
var datasetSelector = document.querySelector('.DataSet');
datasetSelector.addEventListener('change', updateDataSet, false);

var datasetSelector2 = document.querySelector('.DataSet2');
datasetSelector2.addEventListener('change', updateDataSet2, false);

var datasetSelector3 = document.querySelector('.DataSet3');
datasetSelector3.addEventListener('change', updateDataSet3, false);

// Selim's addition for plot.ly.
dataChart = document.getElementById('Chart2D_Left');

dataChart2 = document.getElementById('Chart2D_Right');

dataChart3 = document.getElementById('Chart2D_Bottom');

// Pass data and layout as variables for better code readability.
Plotly.plot( dataChart, dataInitialPos, updateLayoutInitialPos);

Plotly.plot( dataChart2, dataInitialattitudeRate, updateLayoutInitialAngleRate);

Plotly.plot( dataChart3, dataInitialAttitude, updateLayoutInitialAttitude);

// Used for moving the x-axis right/left in play-mode
var dummyVariable = 0;

// Radio Controller
radio_controller.init(document.getElementById('radio-controller'), 300, 200);

// update the radio whenever the time changes
viewer.clock.onTick.addEventListener(function(clock) {
	 var manual_sp = manualControlSetpointsProperty.getValue(clock.currentTime);
	 var flight_mode = flightModesProperty.getValue(clock.currentTime);
	 if (flight_mode === undefined) flight_mode = '';
	 radio_controller.setFlightMode(flight_mode);
	 if (manual_sp === undefined) {
		 radio_controller.hideSticks();
	 } else {
		 // this is mode 2 (map throttle from [0, 1] to [-1, 1])
		 radio_controller.updateSticks(manual_sp.w, manual_sp.z*2.-1.,
			 manual_sp.y, manual_sp.x);

	 }

	 // stick history
	 var stick_history = [];
	 var time = clock.currentTime.clone();

	 //console.log(time.secondsOfDay)

	 for (var i = 0; i < 30; ++i) {
		 manual_sp = manualControlSetpointsProperty.getValue(time);
		 if (manual_sp !== undefined) {
			 stick_history.unshift([manual_sp.w, manual_sp.z*2.-1.,
				 manual_sp.y, manual_sp.x]);
		 }
		 Cesium.JulianDate.addSeconds(time, -0.03333, time);
	 }
	 radio_controller.updateHistory(stick_history);

	 radio_controller.redraw();

	// Updates for 2D charting are made with the radio panel.
	dummyVariable = (time.secondsOfDay - start.secondsOfDay) /60.0;
	var update = {xaxis:  {range: [-totalTimeInSec+dummyVariable, totalTimeInSec+dummyVariable],tickfont:{color: '#00ffff'}}}
	Plotly.relayout(dataChart, update)	 
	Plotly.relayout(dataChart2, update)	
	Plotly.relayout(dataChart3, update)	
});

// additional keyboard handling
document.addEventListener('keyup', function(e) {
	if (e.keyCode == ' '.charCodeAt(0)) { // space
		viewer.clock.shouldAnimate = !viewer.clock.shouldAnimate;
	} else if (e.keyCode == 37) { // arrow left
		if (viewer.clock.multiplier > 0)
			viewer.clock.multiplier = -viewer.clock.multiplier;
		viewer.clock.shouldAnimate = true;
	} else if (e.keyCode == 39) { // arrow right
		if (viewer.clock.multiplier < 0)
			viewer.clock.multiplier = -viewer.clock.multiplier;
		viewer.clock.shouldAnimate = true;
	} else if (e.keyCode == 38) { // arrow up
		viewer.clock.multiplier *= 1.5;
	} else if (e.keyCode == 40) { // arrow down
		viewer.clock.multiplier /= 1.5;
	}
}, false);


// UI: configuration
var viewModel = {
    size : default_model_scale,
    path_visible : true,
    track_vehicle : false,
};
// Convert the viewModel members into knockout observables.
Cesium.knockout.track(viewModel);

// Bind the viewModel to the DOM elements of the UI that call for it.
var toolbar = document.getElementById('toolbar');
Cesium.knockout.applyBindings(viewModel, toolbar);

Cesium.knockout.getObservable(viewModel, 'size').subscribe(
    function(newValue) {
		entity.model.scale = newValue * model_scale_factor;
    }
);
Cesium.knockout.getObservable(viewModel, 'path_visible').subscribe(
    function(newValue) {
		entity.path.show = newValue;
    }
);
Cesium.knockout.getObservable(viewModel, 'track_vehicle').subscribe(
    function(newValue) {
		if (newValue) {
			viewer.trackedEntity = entity;
		} else {
			viewer.trackedEntity = undefined;
		}
    }
);

// initial view: show the vehicle from top
viewer.zoomTo(entity, new Cesium.HeadingPitchRange(0,
	Cesium.Math.toRadians(-90), 200));



  </script>
</body>
</html>

